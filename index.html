<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diamond Nebula - Interactive Gesture Art</title>
    <style>
        /* --- Cinematic UI Theme: Romantic Pink --- */
        :root {
            --bg-color: #0d1f18; 
            --ui-bg: rgba(20, 10, 15, 0.7);
            --gold: #FF69B4; /* Hot Pink */
            --gold-shine: #FF1493; /* Deep Pink */
            --text-color: #FFB6C1; /* Light Pink */
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', 'Helvetica Neue', sans-serif;
            color: var(--text-color);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transition: filter 0.5s;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            padding: 25px;
            background: var(--ui-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 105, 180, 0.3);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 10;
            transition: opacity 0.3s, transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* UI éšè—çŠ¶æ€ */
        #ui-layer.ui-hidden {
            transform: translateX(calc(-100% - 40px));
        }

        /* ä¾§è¾¹åˆ‡æ¢æŒ‰é’® */
        #ui-toggle-btn {
            position: absolute;
            top: 20px;
            right: -40px;
            width: 40px;
            height: 40px;
            background: var(--ui-bg);
            border-radius: 0 12px 12px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #FF69B4;
            border: 1px solid rgba(255, 105, 180, 0.3);
            border-left: none;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: 5px 0 15px rgba(0,0,0,0.2);
            font-size: 1.2rem;
            pointer-events: auto; /* ç¡®ä¿å¯ç‚¹å‡» */
        }
        #ui-toggle-btn:hover {
            background: rgba(255, 105, 180, 0.2);
        }

        /* ç¥ç¦è¯­æ ·å¼ */
        .wish-text {
            font-family: 'Segoe UI', sans-serif;
            font-size: 0.9rem;
            color: #FFB6C1;
            margin-bottom: 20px;
            font-style: italic;
            text-shadow: 0 0 5px rgba(255, 105, 180, 0.4);
            line-height: 1.4;
            border-left: 3px solid #FF69B4;
            background: linear-gradient(90deg, rgba(255, 105, 180, 0.1) 0%, rgba(0,0,0,0) 100%);
            padding: 10px 15px;
            border-radius: 0 8px 8px 0;
            font-weight: 500;
        }

        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            #ui-layer {
                width: 85%;
                max-width: 320px;
                padding: 20px;
                top: 10px;
                left: 10px;
            }
            .wish-text {
                font-size: 0.85rem;
            }
        }

        h1 {
            font-size: 1.4rem;
            font-weight: 300;
            margin: 0 0 20px 0;
            color: #FF69B4; /* ç²‰è‰² */
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 15px rgba(255, 105, 180, 0.6);
            border-bottom: 1px solid rgba(255, 105, 180, 0.5);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.85rem;
            color: #FFB6C1; /* æµ…ç²‰è‰² */
            letter-spacing: 1px;
        }

        /* Modern File Input */
        input[type="file"] { display: none; }
        .file-upload-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
            border: 1px dashed #FF69B4;
            border-radius: 8px;
            background: rgba(255, 105, 180, 0.05);
            color: #FF69B4;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        .file-upload-btn:hover {
            background: rgba(255, 105, 180, 0.15);
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.3);
        }

        /* Modern Color Picker */
        .color-wrapper {
            position: relative;
            height: 40px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }
        input[type="color"] {
            width: 150%; 
            height: 150%; 
            position: absolute;
            top: -25%; left: -25%;
            border: none;
            background: none;
            cursor: pointer;
        }

        /* Action Buttons */
        .btn {
            width: 100%;
            padding: 12px;
            background: transparent;
            border: 1px solid #FF69B4;
            color: #FF69B4;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 0.8rem;
            transition: all 0.3s;
            margin-top: 10px;
        }
        .btn:hover {
            background: #FF69B4;
            color: #000;
            box-shadow: 0 0 20px #FF69B4;
        }

        /* Status & Guide */
        .status-panel {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #333;
            box-shadow: 0 0 5px #333;
            transition: all 0.3s;
        }
        .status-dot.active {
            background: #FF69B4;
            box-shadow: 0 0 10px #FF69B4;
        }
        
        .guide-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.75rem;
            color: #FFB6C1; /* ç²‰è‰² */
        }
        .guide-item i { color: #FF69B4; width: 20px; display: inline-block; }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 1px solid rgba(255, 105, 180, 0.5);
            background: radial-gradient(circle, rgba(20, 10, 15, 0.9) 0%, rgba(0,0,0,0.8) 100%);
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.3);
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Camera Preview (Picture-in-Picture) */
        #cam-preview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid rgba(255, 105, 180, 0.5);
            overflow: hidden;
            z-index: 5;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s;
            transform: scaleX(-1);
            background: #000;
        }
        #cam-preview.visible { opacity: 0.8; }
        #video-feed { width: 100%; height: 100%; object-fit: cover; }

        /* Anthony's Encouragement Overlay */
        #message-layer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 20;
            width: 100%;
        }
        .encourage-text {
            font-family: 'Playfair Display', serif;
            font-size: 3.5rem;
            color: #FF69B4; /* ç²‰è‰²å­—ä½“ */
            text-shadow: 0 0 30px #FF1493, 0 0 60px #FF69B4, 0 0 90px rgba(255,105,180,0.5);
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
            /* ç§»é™¤æ¸å˜èƒŒæ™¯è£å‰ª */
        }
        .encourage-text.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Loading Screen */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s;
        }
        .loader-ring {
            width: 60px; height: 60px;
            border: 2px solid rgba(255,105,180,0.2);
            border-top-color: #FF69B4;
            border-radius: 50%;
            animation: spin 1s infinite linear;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        /* äº¤äº’æç¤ºåŠ¨ç”» */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #interaction-hint.active {
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
    
    <!-- Libraries -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <!-- MediaPipe CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Loading -->
    <div id="loader">
        <div class="loader-ring"></div>
        <p style="color:#FF69B4; margin-top:20px; letter-spacing:2px; font-size:0.8rem;">INITIALIZING NEBULA CORE</p>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Panel -->
    <div id="ui-layer">
        <!-- ä¾§è¾¹åˆ‡æ¢æŒ‰é’® -->
        <div id="ui-toggle-btn">
            <i class="fas fa-chevron-left"></i>
        </div>

        <h1>Diamond Nebula</h1>
        
        <!-- ç¥ç¦è¯­ -->
        <div class="wish-text">yuqi wishes Anthony can breakthrough all the barriers QwQ</div>
        
        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimap-canvas" width="150" height="150"></canvas>
        </div>

        <div class="control-group">
            <label>PARTICLE AURA</label>
            <div class="color-wrapper">
                <input type="color" id="color-picker" value="#D4AF37">
            </div>
        </div>

        <div class="control-group">
            <label>PHOTO (FIXED & UPLOAD)</label>
            <label for="img-upload" class="file-upload-btn">
                <i class="fas fa-image" style="margin-right:10px;"></i> Select Image
            </label>
            <input type="file" id="img-upload" accept="image/*">
        </div>

        <div class="control-group">
            <button id="fullscreen-btn" class="btn">ENTER IMMERSION</button>
            <button id="cam-toggle" class="btn" style="border-color: rgba(255,255,255,0.2); color:#aaa;">DEBUG CAMERA</button>
            <button id="sound-toggle" class="btn" style="border-color: rgba(255,255,255,0.2); color:#aaa;">
                <i class="fas fa-volume-mute"></i> SOUND
            </button>
        </div>

        <div class="status-panel">
            <div class="status-row">
                <span style="font-size:0.8rem; color:var(--gold);">SYSTEM STATUS</span>
                <div id="status-light" class="status-dot"></div>
            </div>
            <div class="guide-grid">
                <div class="guide-item"><i class="fas fa-hand-paper"></i> Open: Enlarge</div>
                <div class="guide-item"><i class="fas fa-hand-rock"></i> Fist: Shrink</div>
                <div class="guide-item"><i class="fas fa-hand-peace"></i> Peace: Fireworks</div>
                <div class="guide-item"><i class="fas fa-arrows-alt"></i> Move: Follow</div>
            </div>
            
            <!-- å½“å‰æ‰‹åŠ¿æŒ‡ç¤º -->
            <div id="gesture-indicator" style="margin-top:15px; padding:10px; background:rgba(255,105,180,0.1); border-radius:8px; font-size:0.8rem; text-align:center; color:#FFB6C1;">
                <div id="gesture-status">Gesture: <span id="current-gesture" style="color:#FF69B4; font-weight:bold;">None</span></div>
                <div style="margin-top:8px; font-size:0.7rem; color:#FFB6C1;">
                    ğŸ’¡ Peace tip: extend index & middle, fold ring & pinky
                </div>
            </div>
            
            <!-- äº¤äº’æç¤º -->
            <div id="interaction-hint" style="margin-top:15px; padding:10px; background:rgba(255,105,180,0.1); border-radius:8px; font-size:0.75rem; color:#FFB6C1; text-align:center; opacity:0; transition:opacity 0.3s;">
                <i class="fas fa-hand-pointer" style="color:#FF69B4; margin-right:5px;"></i>
                <span id="hint-text">Move your hand near the photo to interact</span>
            </div>
        </div>
    </div>

    <!-- Camera Preview -->
    <div id="cam-preview">
        <video id="video-feed"></video>
    </div>

    <!-- Encouragement Overlay -->
    <div id="message-layer">
        <div id="msg-text" class="encourage-text"></div>
    </div>

    <!-- Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Config ---
        const CONFIG = {
            particleCount: 30000, // å¢åŠ åˆ°3ä¸‡ç²’å­
            photoRatio: 0.2,
            radius: 3.5,
            color: new THREE.Color(0xD4AF37),
            bgColor: 0x0d1f18,
            particleSize: 0.015, // æ›´ç»†è…»
            photoSize: 0.12
        };

        const ANTHONY_QUOTES = [
            "Pure Magic, Anthony!", "Shine Bright, Anthony!", "Mastering the Arts, Anthony!",
            "Infinite Possibilities, Anthony", "Spectacular Control, Anthony!", "You Create Beauty, Anthony",
            "Amazing Energy, Anthony!", "Limitless Potential, Anthony!", "Starlight Vision, Anthony",
            "Keep Soaring, Anthony!", "Brilliant Mind, Anthony", "Cosmic Power, Anthony!",
            "Artistry in Motion, Anthony", "You Are The Future, Anthony", "Golden Touch, Anthony!",
            "Dream Big, Anthony!", "Unstoppable, Anthony!", "Radiant Soul, Anthony",
            "Creating Worlds, Anthony", "Visionary, Anthony!", "Pure Genius, Anthony",
            "Beyond Limits, Anthony", "Captivating, Anthony!", "Stunning Work, Anthony",
            "Simply The Best, Anthony!", "Universe Awaits, Anthony", "Lighting The Way, Anthony",
            "Legendary, Anthony!", "Phenomenal, Anthony!", "Inspired, Anthony",
            "Magical Moments, Anthony", "True Talent, Anthony!", "Sky is the Limit, Anthony",
            "Excellence, Anthony!", "Wonder & Awe, Anthony", "Galactic Scale, Anthony!",
            "Your Time To Shine, Anthony", "Absolute Mastery, Anthony", "Creative Force, Anthony",
            "Leading The Way, Anthony!", "Shining Star, Anthony", "Beyond Imagination, Anthony",
            "The World Is Yours, Anthony", "Fantastic, Anthony!", "Incredible, Anthony",
            "Miraculous, Anthony!", "Simply Amazing, Anthony", "Keep Creating, Anthony!",
            "You Light Up The World, Anthony", "Champion, Anthony!",
            "Born To Shine, Anthony!", "Magnificent Work, Anthony!", "True Artist, Anthony",
            "Breathtaking, Anthony!", "Mesmerizing, Anthony!", "Superstar, Anthony",
            "Extraordinary, Anthony!", "Dazzling Performance, Anthony!", "Pure Brilliance, Anthony",
            "Outstanding, Anthony!", "Wonderful Energy, Anthony!", "Genius At Work, Anthony",
            "Amazing Journey, Anthony!", "Limitless Creativity, Anthony!", "Perfect Harmony, Anthony",
            "Stunning Vision, Anthony!", "Beautiful Soul, Anthony", "Inspiring, Anthony!",
            "Incredible Talent, Anthony!", "True Magic, Anthony!", "Powerful, Anthony",
            "Captivating Art, Anthony!", "Divine Creation, Anthony!", "Magnificent, Anthony",
            "Glorious, Anthony!", "Spectacular Vision, Anthony!", "Pure Excellence, Anthony",
            "Marvelous, Anthony!", "Brilliant Creation, Anthony!", "Awesome Power, Anthony!",
            "Supreme Talent, Anthony!", "Perfect Control, Anthony!", "Stellar Performance, Anthony",
            "Radiant Energy, Anthony!", "Cosmic Artist, Anthony!", "Master Creator, Anthony!",
            "Infinite Talent, Anthony!", "Ultimate Vision, Anthony!", "Pure Inspiration, Anthony",
            "Heavenly Touch, Anthony!", "Perfect Flow, Anthony!", "Divine Talent, Anthony",
            "Supreme Artist, Anthony!", "Celestial Beauty, Anthony!", "Unlimited Potential, Anthony!",
            "Absolute Perfection, Anthony!", "Golden Spirit, Anthony!", "True Visionary, Anthony"
        ];

        // --- State ---
        const state = {
            handSpread: 0.5,  // 0 = æ¡æ‹³, 1 = å¼ å¼€
            targetHandSpread: 0.5,
            particleScale: 1, // ç²’å­æ•´ä½“ç¼©æ”¾
            targetParticleScale: 1,
            handPos: new THREE.Vector3(0,0,0),
            handVelocity: new THREE.Vector3(0,0,0),
            lastHandPos: new THREE.Vector3(0,0,0),
            hasHand: false,
            dispersion: 0,
            targetDispersion: 0,
            zoom: 1,
            targetZoom: 1,
            rotationOffset: 0,
            targetRot: 0,
            baseColor: CONFIG.color.clone(),
            explosionActive: false,
            explosionTime: 0,
            systemPosition: new THREE.Vector3(0,0,0),
            systemRotation: 0,
            targetSystemRotation: 0,
            handNearPicture: false,
            pictureScale: 1,
            pictureRotation: 0,
            targetPictureRotation: 0
        };

        let scene, camera, renderer, composer, controls;
        let diamondSystem, photoSystem, bigPicturePlane, explosionSystem, pictureFrame, trailSystem;
        let starField, lightRings, shockwave;
        let spiritSystem, handAuraSystem; // æ–°å¢ï¼šçµåŠ¨å°˜åŸƒå’Œæ‰‹éƒ¨å…‰ç¯
        let heartRings = []; // å‘å…‰çˆ±å¿ƒå…‰ç¯
        let minimapCtx;
        let clock = new THREE.Clock();
        let explosionParticles = [];
        let imageAspectRatio = 1;
        let handTrail = [];
        let audioContext, soundEnabled = false;
        let screenShake = 0; // å±å¹•éœ‡åŠ¨
        let shockwaveActive = false;
        let shockwaveTime = 0;

        // --- éŸ³æ•ˆç³»ç»Ÿ ---
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                soundEnabled = true;
            } catch(e) {
                console.log('Audio not supported');
            }
        }

        // æ”¹è¿›çš„éŸ³æ•ˆç³»ç»Ÿ - ä½¿ç”¨å’Œå¼¦å’Œæ›´å¥½çš„éŸ³è‰²
        function playTone(frequency, duration = 0.1, type = 'sine', volume = 0.15) {
            if(!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // æ’­æ”¾å’Œå¼¦
        function playChord(frequencies, duration = 0.3, type = 'sine') {
            if(!soundEnabled || !audioContext) return;
            frequencies.forEach((freq, index) => {
                setTimeout(() => playTone(freq, duration, type, 0.08), index * 10);
            });
        }

        // æ’­æ”¾æ—‹å¾‹
        function playMelody(notes, interval = 100) {
            if(!soundEnabled || !audioContext) return;
            notes.forEach((note, index) => {
                setTimeout(() => playTone(note.freq, note.duration, note.type || 'sine'), index * interval);
            });
        }

        // Default image will be loaded from same directory as HTML file
        const DEFAULT_IMAGE_NAME = "default-photo.png"; // Place your image file next to this HTML

        // --- Init ---
        async function init() {
            initThree();
            initMinimap();
            createDiamond();
            createExplosionSystem();
            createSpiritSystem();
            createHandAura();
            createHeartExplosion();
            loadDefaultImage();
            initAudio();
            setupEvents();
            
            await waitForLibs();
            try {
                await initVision();
                document.getElementById('loader').style.opacity = 0;
                setTimeout(()=>document.getElementById('loader').remove(), 1000);
            } catch(e) {
                console.error(e);
                alert("Camera access needed for gestures.");
                document.getElementById('loader').style.display = 'none';
            }

            animate();
        }

        function loadDefaultImage() {
            // Try to load from same directory, or use a fallback
            const loader = new THREE.TextureLoader();
            const imagePath = DEFAULT_IMAGE_NAME;
            
            loader.load(
                imagePath,
                (tex) => {
                    tex.needsUpdate = true;
                    imageAspectRatio = tex.image.width / tex.image.height;
                    // apply to photo particles
                    if(photoSystem) {
                        photoSystem.material.map = tex;
                        photoSystem.material.opacity = 0.95;
                        photoSystem.material.needsUpdate = true;
                    }
                    // apply to big picture
                    if(bigPicturePlane) {
                        bigPicturePlane.material.map = tex;
                        bigPicturePlane.material.needsUpdate = true;
                        const size = calculateFitSize(tex.image.width, tex.image.height, camera.position.z);
                        bigPicturePlane.scale.set(size.width, size.height, 1);
                        if(pictureFrame) pictureFrame.scale.set(size.width, size.height, 1);
                    }
                },
                undefined,
                (err) => {
                    console.log('Default image not found, user can upload via UI');
                }
            );
        }

        // --- Minimap ---
        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            minimapCtx = canvas.getContext('2d');
        }

        function updateMinimap() {
            if(!minimapCtx) return;
            const width = 150;
            const height = 150;
            const centerX = width/2;
            const centerY = height/2;
            
            minimapCtx.clearRect(0,0,width,height);
            
            // ç»˜åˆ¶æ˜Ÿç³»èƒŒæ™¯ï¼ˆé™æ€ï¼‰
            const gradient = minimapCtx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 70);
            gradient.addColorStop(0, 'rgba(255, 105, 180, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            minimapCtx.fillStyle = gradient;
            minimapCtx.fillRect(0,0,width,height);
            
            // ç»˜åˆ¶æ‰‹éƒ¨ä½ç½®
            if(state.hasHand) {
                // å°†3Dåæ ‡æ˜ å°„åˆ°2Då°åœ°å›¾
                // å‡è®¾æ´»åŠ¨èŒƒå›´ x: -5~5, y: -3~3
                const mapX = centerX + (state.handPos.x / 5) * (width * 0.4);
                const mapY = centerY - (state.handPos.y / 3) * (height * 0.4); // Yè½´ç¿»è½¬
                
                minimapCtx.beginPath();
                minimapCtx.arc(mapX, mapY, 4, 0, Math.PI*2);
                minimapCtx.fillStyle = '#FF69B4';
                minimapCtx.shadowBlur = 10;
                minimapCtx.shadowColor = '#FF69B4';
                minimapCtx.fill();
                
                // ç»˜åˆ¶æ–¹å‘æŒ‡ç¤º
                minimapCtx.beginPath();
                minimapCtx.moveTo(centerX, centerY);
                minimapCtx.lineTo(mapX, mapY);
                minimapCtx.strokeStyle = 'rgba(255, 105, 180, 0.5)';
                minimapCtx.stroke();
            }
        }

        // --- Three.js Setup ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(CONFIG.bgColor, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.z = 10;
            camera.position.y = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ä»¥æé«˜æ€§èƒ½
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;

            // Post-Processing
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 
                1.8, 0.5, 0.8
            );
            bloomPass.threshold = 0.1;
            bloomPass.strength = 1.5;
            bloomPass.radius = 0.9;

            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            
            // å­˜å‚¨bloom passä»¥ä¾¿åŠ¨æ€è°ƒæ•´
            window.bloomPass = bloomPass;

            window.addEventListener('resize', onResize);
        }

        // --- Particle Core ---
        function createDiamond() {
            const geo = new THREE.OctahedronGeometry(CONFIG.radius, 5); // æ›´é«˜ç»†åˆ†åº¦
            const vertices = geo.attributes.position.array;
            
            const pPositions = [];
            const pOriginals = [];
            const pColors = [];
            const pSizes = [];
            const photoPos = [];
            const photoOrig = [];
            const colorVar = new THREE.Color();

            for (let i = 0; i < vertices.length; i+=3) {
                const x = vertices[i];
                const y = vertices[i+1];
                const z = vertices[i+2];

                if (Math.random() < CONFIG.photoRatio) {
                    photoPos.push(x,y,z);
                    photoOrig.push(x,y,z);
                } else {
                    pPositions.push(x,y,z);
                    pOriginals.push(x,y,z);
                    
                    if (Math.random() > 0.85) {
                        colorVar.setHex(0xFFFFFF);
                        pSizes.push(Math.random() * 0.05 + 0.03);
                    } else {
                        colorVar.copy(state.baseColor);
                        colorVar.offsetHSL(0, 0, (Math.random()-0.5)*0.12);
                        pColors.push(colorVar.r, colorVar.g, colorVar.b);
                        pSizes.push(Math.random() * 0.02 + 0.008);
                    }
                }
            }

            // Dust System - æ›´å°æ›´ç»†è…»
            const dustGeo = new THREE.BufferGeometry();
            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            dustGeo.setAttribute('color', new THREE.Float32BufferAttribute(pColors, 3));
            dustGeo.setAttribute('size', new THREE.Float32BufferAttribute(pSizes, 1));
            dustGeo.userData = { original: pOriginals };

            const dustMat = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                map: createGlowTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true
            });
            
            // å­˜å‚¨åŸå§‹é¢œè‰²ç”¨äºåŠ¨æ€å˜åŒ–
            dustGeo.userData.originalColors = new Float32Array(pColors);
            diamondSystem = new THREE.Points(dustGeo, dustMat);
            scene.add(diamondSystem);

            // Photo System
            const planeGeo = new THREE.PlaneGeometry(CONFIG.photoSize, CONFIG.photoSize);
            const planeMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            photoSystem = new THREE.InstancedMesh(planeGeo, planeMat, photoPos.length/3);
            photoSystem.userData = { original: photoOrig, count: photoPos.length/3 };
            
            const dummy = new THREE.Object3D();
            for(let i=0; i<photoSystem.userData.count; i++){
                dummy.position.set(photoPos[i*3], photoPos[i*3+1], photoPos[i*3+2]);
                dummy.lookAt(0,0,0);
                dummy.updateMatrix();
                photoSystem.setMatrixAt(i, dummy.matrix);
            }
            scene.add(photoSystem);

            // Big Picture Plane - ä½¿ç”¨æ›´åˆé€‚çš„å°ºå¯¸
            const bigGeo = new THREE.PlaneGeometry(1, 1); // åŸºå‡†å°ºå¯¸ï¼Œä¼šæ ¹æ®å›¾ç‰‡åŠ¨æ€è°ƒæ•´
            const bigMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide,
                blending: THREE.NormalBlending,
                depthWrite: false
            });
            bigPicturePlane = new THREE.Mesh(bigGeo, bigMat);
            bigPicturePlane.visible = false;
            bigPicturePlane.position.z = 3; // åœ¨ç²’å­å‰æ–¹
            scene.add(bigPicturePlane);

            // åˆ›å»ºå›¾ç‰‡è¾¹æ¡†ç²’å­æ•ˆæœ
            createPictureFrame();
            
            // åˆ›å»ºæ‰‹éƒ¨è½¨è¿¹ç³»ç»Ÿ
            createTrailSystem();
            
            // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯
            createStarField();
            
            // åˆ›å»ºå†²å‡»æ³¢
            createShockwave();
        }

        // --- å›¾ç‰‡è¾¹æ¡†ç²’å­ç³»ç»Ÿï¼ˆå¢å¼ºäº’åŠ¨æ€§ï¼‰ ---
        function createPictureFrame() {
            const particleCount = 400;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for(let i = 0; i < particleCount; i++) {
                // åˆå§‹ä½ç½®åœ¨çŸ©å½¢è¾¹æ¡†ä¸Š
                const side = Math.floor(Math.random() * 4);
                const t = Math.random();
                
                if(side === 0) { // ä¸Šè¾¹
                    positions[i*3] = (t - 0.5) * 2;
                    positions[i*3+1] = 1;
                } else if(side === 1) { // å³è¾¹
                    positions[i*3] = 1;
                    positions[i*3+1] = (t - 0.5) * 2;
                } else if(side === 2) { // ä¸‹è¾¹
                    positions[i*3] = (t - 0.5) * 2;
                    positions[i*3+1] = -1;
                } else { // å·¦è¾¹
                    positions[i*3] = -1;
                    positions[i*3+1] = (t - 0.5) * 2;
                }
                positions[i*3+2] = 0;

                // é‡‘è‰²è¾¹æ¡†ç²’å­
                const c = new THREE.Color().setHSL(0.12 + Math.random() * 0.05, 0.9, 0.6);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
                
                sizes[i] = Math.random() * 0.06 + 0.03;
            }

            const frameGeo = new THREE.BufferGeometry();
            frameGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            frameGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            frameGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const frameMat = new THREE.PointsMaterial({
                size: 0.05,
                map: createGlowTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0
            });

            pictureFrame = new THREE.Points(frameGeo, frameMat);
            pictureFrame.visible = false;
            pictureFrame.position.z = 3.1; // ç¨å¾®åœ¨å›¾ç‰‡å‰æ–¹
            scene.add(pictureFrame);
        }

        // --- çµåŠ¨å°˜åŸƒç³»ç»Ÿ (Spirit Dust - ä¸Šå‡çš„é‡‘è‰²å¾®ç²’) ---
        function createSpiritSystem() {
            const count = 500;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const speeds = new Float32Array(count);

            for(let i=0; i<count; i++) {
                positions[i*3] = (Math.random() - 0.5) * 15;
                positions[i*3+1] = (Math.random() - 0.5) * 10 - 5;
                positions[i*3+2] = (Math.random() - 0.5) * 5;
                
                const c = new THREE.Color().setHSL(0.1 + Math.random()*0.1, 0.8, 0.6 + Math.random()*0.4);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
                
                sizes[i] = Math.random() * 0.1 + 0.05;
                speeds[i] = Math.random() * 0.5 + 0.2; // ä¸Šå‡é€Ÿåº¦
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geo.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));

            const mat = new THREE.PointsMaterial({
                size: 0.1,
                map: createGlowTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.6
            });

            spiritSystem = new THREE.Points(geo, mat);
            scene.add(spiritSystem);
        }

        function updateSpiritSystem(dt, time) {
            if(!spiritSystem) return;
            
            const positions = spiritSystem.geometry.attributes.position.array;
            const speeds = spiritSystem.geometry.attributes.speed.array;
            const sizes = spiritSystem.geometry.attributes.size.array;
            
            for(let i=0; i<speeds.length; i++) {
                // å‘ä¸Šç§»åŠ¨
                positions[i*3+1] += speeds[i] * dt;
                
                // å·¦å³æ‘‡æ‘†
                positions[i*3] += Math.sin(time + i) * 0.01;
                
                // å‘¼å¸æ•ˆæœ
                sizes[i] = (Math.sin(time * 3 + i) * 0.5 + 1) * (0.05 + speeds[i]*0.1);
                
                // å¾ªç¯é‡ç½®
                if(positions[i*3+1] > 6) {
                    positions[i*3+1] = -6;
                    positions[i*3] = (Math.random() - 0.5) * 15;
                }
            }
            
            spiritSystem.geometry.attributes.position.needsUpdate = true;
            spiritSystem.geometry.attributes.size.needsUpdate = true;
        }

        // --- æ‰‹éƒ¨å…‰ç¯ç³»ç»Ÿ (Hand Aura - ç¯ç»•æ‰‹éƒ¨çš„èƒ½é‡åœº) ---
        function createHandAura() {
            const count = 200;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const phases = new Float32Array(count);

            for(let i=0; i<count; i++) {
                positions[i*3] = 0; positions[i*3+1] = 0; positions[i*3+2] = 0;
                
                const c = new THREE.Color().setHSL(0.5 + Math.random()*0.2, 0.9, 0.7); // è“ç´«è‰²è°ƒ
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
                
                sizes[i] = Math.random() * 0.08 + 0.02;
                phases[i] = Math.random() * Math.PI * 2;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            const mat = new THREE.PointsMaterial({
                size: 0.1,
                map: createGlowTexture(true), // æ˜Ÿæ˜Ÿå½¢çŠ¶
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0
            });

            handAuraSystem = new THREE.Points(geo, mat);
            scene.add(handAuraSystem);
        }

        function updateHandAura(dt) {
            if(!handAuraSystem) return;
            
            // åªæœ‰æ£€æµ‹åˆ°æ‰‹æ—¶æ‰æ˜¾ç¤º
            const targetOpacity = state.hasHand ? 0.8 : 0;
            handAuraSystem.material.opacity += (targetOpacity - handAuraSystem.material.opacity) * 0.1;
            
            if(handAuraSystem.material.opacity < 0.01) return;
            
            const positions = handAuraSystem.geometry.attributes.position.array;
            const phases = handAuraSystem.geometry.attributes.phase.array;
            const time = clock.getElapsedTime();
            
            for(let i=0; i<phases.length; i++) {
                // å›´ç»•æ‰‹éƒ¨æ—‹è½¬
                const radius = 0.4 + Math.sin(time * 3 + phases[i]) * 0.1;
                const angle = time * 2 + phases[i];
                const height = Math.cos(time * 4 + phases[i]) * 0.3;
                
                // åŸºç¡€ä½ç½®ï¼šè·Ÿéšæ‰‹éƒ¨
                const cx = state.handPos.x;
                const cy = state.handPos.y;
                const cz = state.handPos.z;
                
                // èºæ—‹è¿åŠ¨
                positions[i*3] = cx + Math.cos(angle) * radius;
                positions[i*3+1] = cy + height;
                positions[i*3+2] = cz + Math.sin(angle) * radius;
            }
            
            handAuraSystem.geometry.attributes.position.needsUpdate = true;
        }

        // --- çˆ±å¿ƒçˆ†ç‚¸èƒŒæ™¯ç‰¹æ•ˆ (Heart Explosion Background) ---
        let heartExplosionSystem;
        let heartTexture;

        function createHeartTexture() {
            const c = document.createElement('canvas');
            c.width = 256; c.height = 256; // æé«˜åˆ†è¾¨ç‡ä»¥æ”¯æŒå¤§çˆ±å¿ƒ
            const ctx = c.getContext('2d');
            
            // ç»˜åˆ¶å‘å…‰çˆ±å¿ƒ
            ctx.translate(128, 128);
            ctx.scale(2, -2); // æ”¾å¤§ç»˜å›¾
            
            // å¤–å±‚å…‰æ™•
            const grd = ctx.createRadialGradient(0, 0, 10, 0, 0, 60);
            grd.addColorStop(0, 'rgba(255, 105, 180, 1)'); // HotPink
            grd.addColorStop(0.4, 'rgba(255, 20, 147, 0.8)'); // DeepPink
            grd.addColorStop(1, 'rgba(255, 20, 147, 0)');
            ctx.fillStyle = grd;
            
            ctx.beginPath();
            for(let t=0; t<Math.PI*2; t+=0.1) {
                const x = 32 * Math.pow(Math.sin(t), 3);
                const y = 26 * Math.cos(t) - 10 * Math.cos(2*t) - 4 * Math.cos(3*t) - 2 * Math.cos(4*t);
                ctx.lineTo(x, y);
            }
            ctx.fill();
            
            // æ ¸å¿ƒé«˜å…‰ (æ›´äº®)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.beginPath();
            for(let t=0; t<Math.PI*2; t+=0.1) {
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                ctx.lineTo(x, y);
            }
            ctx.fill();
            
            const t = new THREE.Texture(c);
            t.needsUpdate = true;
            return t;
        }

        function createHeartExplosion() {
            heartTexture = createHeartTexture();
            const count = 5000; // å¢åŠ ç²’å­æ•°é‡
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const velocities = new Float32Array(count * 3);
            const phases = new Float32Array(count);

            for(let i=0; i<count; i++) {
                // åˆå§‹ä½ç½®åœ¨ä¸­å¿ƒ
                positions[i*3] = 0;
                positions[i*3+1] = 0;
                positions[i*3+2] = 0;

                // éšæœºå‘å¤–çˆ†å‘çš„é€Ÿåº¦
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = Math.random() * 6 + 2; 
                
                velocities[i*3] = Math.sin(phi) * Math.cos(theta) * speed;
                velocities[i*3+1] = Math.sin(phi) * Math.sin(theta) * speed;
                velocities[i*3+2] = Math.cos(phi) * speed;

                // é¢œè‰²ï¼šç²‰è‰²ç³»ï¼Œæ›´åŠ ä¸°å¯Œ
                const c = new THREE.Color();
                const rnd = Math.random();
                if (rnd > 0.9) {
                    c.setHex(0xFFFFFF); // çº¯ç™½é«˜å…‰
                } else if (rnd > 0.6) {
                    c.setHex(0xFF1493); // æ·±ç²‰
                } else {
                    c.setHex(0xFF69B4); // çƒ­ç²‰
                }
                
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;

                // å¤§å°å˜åŒ–ï¼šåŠ å…¥å¤§çˆ±å¿ƒ
                const isBig = Math.random() < 0.08;
                if (isBig) { // 8% çš„æ¦‚ç‡æ˜¯å¤§çˆ±å¿ƒ
                    sizes[i] = Math.random() * 1.5 + 0.8; // å·¨å¤§æ˜¾çœ¼
                } else {
                    sizes[i] = Math.random() * 0.3 + 0.1; // æ™®é€š
                }
                
                phases[i] = Math.random() + (isBig ? 10 : 0); // æ ‡è®°å¤§çˆ±å¿ƒ (phase > 5)
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geo.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            const mat = new THREE.PointsMaterial({
                size: 0.2, // åŸºç¡€å¤§å°ï¼Œä¼šè¢« attribute è¦†ç›–
                map: heartTexture,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0
            });

            heartExplosionSystem = new THREE.Points(geo, mat);
            scene.add(heartExplosionSystem);
        }

        function updateHeartExplosion(dt, time) {
            if(!heartExplosionSystem) return;
            const isPeace = state.targetDispersion > 2.5;
            
            // æ·¡å…¥æ·¡å‡º
            const targetOpacity = isPeace ? 1.0 : 0;
            heartExplosionSystem.material.opacity += (targetOpacity - heartExplosionSystem.material.opacity) * 0.1;
            
            // å¦‚æœä¸æ˜¾ç¤ºï¼Œä¸æ›´æ–°ä½ç½®ä»¥èŠ‚çœæ€§èƒ½ï¼ˆæˆ–è€…é‡ç½®ï¼‰
            if(heartExplosionSystem.material.opacity < 0.01) {
                heartExplosionSystem.visible = false;
                return;
            }
            heartExplosionSystem.visible = true;
            
            // çˆ±å¿ƒç²’å­ä¸€ç›´å‘å¤–çˆ†ç‚¸
            const positions = heartExplosionSystem.geometry.attributes.position.array;
            const velocities = heartExplosionSystem.geometry.attributes.velocity.array;
            const sizes = heartExplosionSystem.geometry.attributes.size.array;
            const phases = heartExplosionSystem.geometry.attributes.phase.array;
            
            for(let i=0; i<positions.length/3; i++) {
                // ç§»åŠ¨
                positions[i*3] += velocities[i*3] * dt;
                positions[i*3+1] += velocities[i*3+1] * dt;
                positions[i*3+2] += velocities[i*3+2] * dt;
                
                // å‘¼å¸æ•ˆæœ
                const pulse = Math.sin(time * 5 + phases[i] * 10) * 0.2 + 1;
                // ä½¿ç”¨ geometry ä¸­çš„ size å±æ€§ä½œä¸ºåŸºå‡†ï¼Œè¿™æ ·å¤§çˆ±å¿ƒå’Œå°çˆ±å¿ƒéƒ½ä¼šå‘¼å¸
                // æ³¨æ„ï¼šåœ¨ update ä¸­ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ¯å¸§éƒ½é‡å†™åŸºå‡†å¤§å°ï¼Œè€Œæ˜¯åŸºäº attribute[i]
                // ä½†æ˜¯ geometry.attributes.size.array[i] å·²ç»è¢«ä¿®æ”¹äº†
                // æ­£ç¡®åšæ³•ï¼šåº”è¯¥ä¿å­˜åŸå§‹å¤§å°ã€‚ä½†ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬é‡æ–°è®¡ç®—æˆ–ä»…åº”ç”¨ç¼©æ”¾å› å­
                
                // è¿™é‡Œæˆ‘ä»¬ç®€åŒ–ï¼šå¤§çˆ±å¿ƒå’Œå°çˆ±å¿ƒåœ¨åˆ›å»ºæ—¶å·²ç»åŒºåˆ†äº† size
                // æˆ‘ä»¬ä¸éœ€è¦å†æ¬¡åŒºåˆ†ï¼Œç›´æ¥ä¹˜ pulse å³å¯ï¼Œä½†è¦æ³¨æ„ä¸è¦è®© size æ— é™å¢é•¿
                // ç”±äºæˆ‘ä»¬æ˜¯åœ¨æ¯ä¸€å¸§ç›´æ¥èµ‹å€¼ï¼Œæ‰€ä»¥éœ€è¦çŸ¥é“"åŸå§‹å¤§å°"
                
                // æ›´å¥½çš„æ–¹å¼ï¼šåˆ›å»ºæ—¶ sizes[i] å­˜å‚¨åŸå§‹å¤§å°ï¼Œè¿™é‡Œä»…åœ¨ shader ä¸­ç¼©æ”¾ï¼Œæˆ–è€…æˆ‘ä»¬è¿™é‡Œç¡¬ç¼–ç 
                // æ—¢ç„¶æˆ‘ä»¬åœ¨ JS ä¸­æ›´æ–°ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„æ–¹æ³•ï¼š
                // æˆ‘ä»¬åœ¨ create æ—¶è®¾å®šçš„ sizes åªæ˜¯åˆå§‹å€¼ï¼Œåœ¨ update ä¸­æˆ‘ä»¬è¦†ç›–å®ƒ
                
                // é‡æ–°å®ç°å¤§å°é€»è¾‘ï¼š
                let baseSize = 0.1;
                if (sizes[i] > 0.5) baseSize = 1.0; // å¦‚æœå½“å‰æ˜¯å¤§çˆ±å¿ƒèŒƒå›´ (ä¹‹å‰è®¾å®šçš„ 0.8~2.3)
                else baseSize = 0.2; // å°çˆ±å¿ƒ
                
                // ä¸ºäº†ä¿æŒå¤§çˆ±å¿ƒçš„å¤§å°ºå¯¸ï¼Œæˆ‘ä»¬åˆ©ç”¨ phases[i] æ¥åˆ¤æ–­æ˜¯å¦æ˜¯å¤§çˆ±å¿ƒ
                // åœ¨ create ä¸­ï¼šif (Math.random() < 0.08) -> å¤§çˆ±å¿ƒ
                // æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ velocities çš„å¤§å°æˆ–è€…å…¶ä»–ç‰¹å¾æ¥åˆ¤æ–­ï¼Œæˆ–è€…å¹²è„†é‡æ–°éšæœº (ä¸æ¨èï¼Œä¼šé—ªçƒ)
                
                // æœ€ç¨³å¦¥ï¼šåˆ©ç”¨ sizes[i] çš„å½“å‰å€¼ã€‚å¦‚æœå®ƒå¾ˆå¤§ï¼Œå®ƒå°±æ˜¯å¤§çˆ±å¿ƒã€‚
                // ä½†æ˜¯ sizes[i] ä¼šè¢«è„‰å†²ä¿®æ”¹ã€‚
                // è®©æˆ‘ä»¬åœ¨ phases ä¸­å­˜å‚¨ä¸€ä¸ªæ ‡è®°ï¼Ÿä¸ï¼Œphases æ˜¯ floatã€‚
                
                // è®©æˆ‘ä»¬ç®€å•ç‚¹ï¼šå¤§çˆ±å¿ƒåœ¨ Update ä¸­è¢«èµ‹äºˆç‰¹åˆ«å¤§çš„å°ºå¯¸
                // ä¸ºäº†é¿å…æ ‡è®°ä¸¢å¤±ï¼Œæˆ‘ä»¬é‡æ–°åˆ©ç”¨ sizes æ•°ç»„ï¼Œå‡è®¾ update æ˜¯è¿ç»­çš„
                // å®é™…ä¸Šï¼Œcreate ä¸­è®¾ç½®çš„ sizes åœ¨ç¬¬ä¸€æ¬¡ update å‰æ˜¯é™æ€çš„
                
                // ä¿®æ­£ç­–ç•¥ï¼šåœ¨ create ä¸­ï¼Œæˆ‘ä»¬å°†"æ˜¯å¦æ˜¯å¤§çˆ±å¿ƒ"çš„ä¿¡æ¯ç¼–ç åˆ° phase çš„æ•´æ•°éƒ¨åˆ†ï¼Ÿ
                // æˆ–è€…ï¼Œæˆ‘ä»¬ç®€å•åœ°æ¯æ¬¡éƒ½é‡æ–°è®¡ç®—åŸºå‡†å¤§å°ï¼Ÿä¸è¡Œï¼Œé‚£æ ·ä¼šå¤±å»éšæœºæ€§ã€‚
                
                // è®©æˆ‘ä»¬ä¿®æ”¹ createï¼ŒæŠŠå¤§å°ä¿¡æ¯å­˜åœ¨ phase çš„æ•´æ•°ä½
                // phase[i] = Math.random() + (isBig ? 10 : 0)
                
                // ä½†è¿™é‡Œæˆ‘ä»¬ä¸èƒ½æ”¹ create çš„ç»“æ„å¤ªå¤æ‚ã€‚
                // è®©æˆ‘ä»¬ç›´æ¥åœ¨ update ä¸­åˆ¤æ–­ï¼š
                // å¦‚æœæ˜¯ç¬¬ä¸€å¸§ï¼Œæˆ‘ä»¬ä¸çŸ¥é“ã€‚
                
                // è®©æˆ‘ä»¬å›é€€ä¸€æ­¥ï¼š
                // ç›´æ¥è®©æ‰€æœ‰ç²’å­éƒ½å‘¼å¸ï¼Œå¹…åº¦å–å†³äºå®ƒä»¬å½“å‰çš„å¤§å°ï¼Ÿ
                // ä¸ï¼Œè¿™æ ·ä¼šå¯¼è‡´æ•°å€¼æ¼‚ç§»ã€‚
                
                // æœ€ç»ˆæ–¹æ¡ˆï¼šåœ¨ create ä¸­ï¼ŒæŠŠ å¤§å° å­˜å…¥ userData æˆ–è€…åˆ©ç”¨ phase > 1 æ¥æ ‡è®°
                // åœ¨ createHeartExplosion ä¸­ï¼š phases[i] = Math.random() + (isBig ? 2 : 0);
                
                // ä½†ä¸ºäº†ä¸ç ´åç°æœ‰é€»è¾‘å¤ªä¸¥é‡ï¼Œæˆ‘ä»¬å‡è®¾å¤§çˆ±å¿ƒæ˜¯å°‘æ•°ã€‚
                // æˆ‘ä»¬åœ¨ create ä¸­å·²ç»è®¾ç½®äº† sizesã€‚
                // æˆ‘ä»¬åœ¨ update ä¸­ï¼Œä¸å†è¦†ç›– sizesï¼Œè€Œæ˜¯è®© material sizeAttenuation å¤„ç†ï¼Ÿ
                // ä¸ï¼Œæˆ‘ä»¬éœ€è¦åŠ¨æ€å‘¼å¸ã€‚
                
                // è®©æˆ‘ä»¬ä¿®æ”¹ createHeartExplosion ä¸­çš„ phases èµ‹å€¼ï¼š
                // phase = Math.random()
                // if (isBig) phase += 10;
                
                // ç„¶ååœ¨è¿™é‡Œï¼š
                let isBig = phases[i] > 5;
                let animPhase = phases[i] % 1;
                
                let currentBase = isBig ? 1.5 : 0.2; 
                // æ·»åŠ ä¸€äº›éšæœºæ€§å˜åŒ–ï¼Œåˆ©ç”¨ id (i)
                currentBase += (i % 5) * 0.05; 
                
                sizes[i] = currentBase * pulse;


                // è·ç¦»é‡ç½®ï¼šå¦‚æœè·‘å¤ªè¿œï¼Œé‡ç½®å›ä¸­å¿ƒï¼Œåˆ¶é€ æºæºä¸æ–­çš„æ•ˆæœ
                const dist = Math.sqrt(
                    positions[i*3]**2 + 
                    positions[i*3+1]**2 + 
                    positions[i*3+2]**2
                );
                
                if(dist > 15) {
                    positions[i*3] = (Math.random()-0.5) * 2; // ç¨å¾®æœ‰ç‚¹æ•£å¸ƒçš„æºå¤´
                    positions[i*3+1] = (Math.random()-0.5) * 2;
                    positions[i*3+2] = (Math.random()-0.5) * 2;
                }
            }
            
            heartExplosionSystem.geometry.attributes.position.needsUpdate = true;
            heartExplosionSystem.geometry.attributes.size.needsUpdate = true;
        }

        // --- æ‰‹éƒ¨è½¨è¿¹ç»˜åˆ¶ç³»ç»Ÿ ---
        function createTrailSystem() {
            const maxTrailPoints = 100;
            const positions = new Float32Array(maxTrailPoints * 3);
            const colors = new Float32Array(maxTrailPoints * 3);
            const sizes = new Float32Array(maxTrailPoints);

            for(let i = 0; i < maxTrailPoints; i++) {
                positions[i*3] = 0;
                positions[i*3+1] = 0;
                positions[i*3+2] = 0;
                
                const c = new THREE.Color().setHSL(0.55, 0.8, 0.5);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
                
                sizes[i] = 0.1;
            }

            const trailGeo = new THREE.BufferGeometry();
            trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            trailGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const trailMat = new THREE.PointsMaterial({
                size: 0.08,
                map: createGlowTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.7
            });

            trailSystem = new THREE.Points(trailGeo, trailMat);
            scene.add(trailSystem);
        }

        function updateTrailSystem() {
            if(!trailSystem || !state.hasHand) {
                if(trailSystem) trailSystem.material.opacity *= 0.95;
                return;
            }

            trailSystem.material.opacity = 0.7;

            // æ·»åŠ å½“å‰æ‰‹éƒ¨ä½ç½®åˆ°è½¨è¿¹
            handTrail.push(state.handPos.clone());
            if(handTrail.length > 100) handTrail.shift();

            const positions = trailSystem.geometry.attributes.position.array;
            const colors = trailSystem.geometry.attributes.color.array;
            const sizes = trailSystem.geometry.attributes.size.array;

            for(let i = 0; i < handTrail.length; i++) {
                const point = handTrail[i];
                positions[i*3] = point.x;
                positions[i*3+1] = point.y;
                positions[i*3+2] = point.z;

                // æ¸å˜é¢œè‰²ï¼ˆæ ¹æ®é€Ÿåº¦ï¼‰
                const speed = state.handVelocity.length();
                const hue = 0.55 + speed * 0.3;
                const c = new THREE.Color().setHSL(hue, 0.9, 0.5);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;

                // æ¸å˜å¤§å°
                const age = 1 - (i / handTrail.length);
                sizes[i] = 0.15 * age;
            }

            // æ¸…ç©ºæœªä½¿ç”¨çš„ç‚¹
            for(let i = handTrail.length; i < 100; i++) {
                sizes[i] = 0;
            }

            trailSystem.geometry.attributes.position.needsUpdate = true;
            trailSystem.geometry.attributes.color.needsUpdate = true;
            trailSystem.geometry.attributes.size.needsUpdate = true;
        }

        // --- æ˜Ÿç©ºèƒŒæ™¯ï¼ˆé“¶æ²³ç³»èºæ—‹æ•ˆæœï¼‰ ---
        function createStarField() {
            const starCount = 5000; // æ›´å¤šæ˜Ÿæ˜Ÿ
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            const spiralArms = 3;
            const armSpread = 0.5;

            for(let i = 0; i < starCount; i++) {
                // é“¶æ²³ç³»èºæ—‹ç®—æ³•
                const t = Math.random(); // è·ç¦»ä¸­å¿ƒçš„å½’ä¸€åŒ–è·ç¦»
                const angle = t * Math.PI * 2 * spiralArms + (Math.random() - 0.5) * armSpread;
                const radius = t * 30 + Math.random() * 2; // åŠå¾„
                
                // æ·»åŠ ä¸€äº›éšæœºæ•£å¸ƒçš„æ˜Ÿæ˜Ÿ
                if(Math.random() < 0.2) {
                    const r = 40 + Math.random() * 20;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i*3+2] = r * Math.cos(phi);
                } else {
                    // èºæ—‹è‡‚æ˜Ÿæ˜Ÿ
                    positions[i*3] = radius * Math.cos(angle);
                    positions[i*3+1] = (Math.random() - 0.5) * (5 - t*3); // æ‰å¹³åœ†ç›˜ï¼Œä¸­å¿ƒåšè¾¹ç¼˜è–„
                    positions[i*3+2] = radius * Math.sin(angle);
                }

                // é¢œè‰²ï¼šä¸­å¿ƒé‡‘è‰²/ç™½è‰²ï¼Œè¾¹ç¼˜è“è‰²/ç´«è‰²
                const c = new THREE.Color();
                if(t < 0.2) {
                    c.setHSL(0.1 + Math.random()*0.1, 0.8, 0.8); // é‡‘è‰²ä¸­å¿ƒ
                } else {
                    c.setHSL(0.6 + Math.random()*0.1, 0.6, 0.7); // è“è‰²è¾¹ç¼˜
                }
                
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
                
                sizes[i] = Math.random() * 0.15 + 0.02;
            }

            const starGeo = new THREE.BufferGeometry();
            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const starMat = new THREE.PointsMaterial({
                size: 0.1,
                map: createGlowTexture(true), // ä½¿ç”¨æ›´äº®çš„è´´å›¾
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            starField = new THREE.Points(starGeo, starMat);
            scene.add(starField);
        }

        function updateStarField(time) {
            if(!starField) return;
            // æ•´ä½“ç¼“æ…¢æ—‹è½¬
            starField.rotation.y = time * 0.01;
            
            // é—ªçƒ
            const sizes = starField.geometry.attributes.size.array;
            for(let i=0; i<sizes.length; i+=10) { // ä¼˜åŒ–ï¼šåªæ›´æ–°éƒ¨åˆ†æ˜Ÿæ˜Ÿ
                if(Math.random() > 0.9) {
                    sizes[i] = (Math.random() * 0.15 + 0.02) * (0.8 + Math.sin(time * 5 + i)*0.5);
                }
            }
            starField.geometry.attributes.size.needsUpdate = true;
        }

        // --- Light rings disabled to remove green ring completely ---
        function createLightRings() { lightRings = []; }
        function updateLightRings() { return; }

        // --- Shockwave disabled to avoid any ring ---
        function createShockwave() { shockwave = null; }
        function triggerShockwave() { return; }
        function updateShockwave() { return; }

        // --- è®¡ç®—é€‚åˆè§†å£çš„å›¾ç‰‡å°ºå¯¸ ---
        function calculateFitSize(imageWidth, imageHeight, cameraZ) {
            // è®¡ç®—ç›¸æœºåœ¨ç»™å®šè·ç¦»å¤„çš„å¯è§é«˜åº¦å’Œå®½åº¦
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const distance = Math.abs(cameraZ - bigPicturePlane.position.z);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * distance;
            const visibleWidth = visibleHeight * camera.aspect;

            // ç•™å‡ºè¾¹è·ï¼ˆ90%å¯è§åŒºåŸŸï¼‰
            const maxWidth = visibleWidth * 0.8;
            const maxHeight = visibleHeight * 0.8;

            const imageAspect = imageWidth / imageHeight;
            let finalWidth, finalHeight;

            if (imageAspect > maxWidth / maxHeight) {
                // å›¾ç‰‡æ›´å®½ï¼ŒæŒ‰å®½åº¦é€‚é…
                finalWidth = maxWidth;
                finalHeight = maxWidth / imageAspect;
            } else {
                // å›¾ç‰‡æ›´é«˜ï¼ŒæŒ‰é«˜åº¦é€‚é…
                finalHeight = maxHeight;
                finalWidth = maxHeight * imageAspect;
            }

            return { width: finalWidth, height: finalHeight };
        }

        // --- Explosion System (Peaceæ‰‹åŠ¿çƒŸèŠ±æ•ˆæœ - çº¯ç²’å­) ---
        function createExplosionSystem() {
            const geo = new THREE.BufferGeometry();
            const count = 3000; // æ›´å¤šçˆ†ç‚¸ç²’å­
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const velocities = [];

            for(let i=0; i<count; i++) {
                positions[i*3] = 0;
                positions[i*3+1] = 0;
                positions[i*3+2] = 0;
                
                // éšæœºé¢œè‰²
                const c = new THREE.Color().setHSL(Math.random(), 0.9, 0.7);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
                
                sizes[i] = Math.random() * 0.05 + 0.01;
                
                // éšæœºé€Ÿåº¦å‘é‡ï¼ˆçƒå½¢çˆ†ç‚¸ï¼‰
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = Math.random() * 8 + 4;
                velocities.push({
                    x: Math.sin(phi) * Math.cos(theta) * speed,
                    y: Math.sin(phi) * Math.sin(theta) * speed,
                    z: Math.cos(phi) * speed
                });
            }

            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geo.userData = { velocities };

            const mat = new THREE.PointsMaterial({
                size: 0.05,
                map: createGlowTexture(true), // ä½¿ç”¨æ˜Ÿæ˜Ÿè´´å›¾
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0
            });

            explosionSystem = new THREE.Points(geo, mat);
            explosionSystem.visible = false;
            scene.add(explosionSystem);
        }

        function triggerExplosion(position) {
            state.explosionActive = true;
            state.explosionTime = 0;
            explosionSystem.visible = true;
            explosionSystem.position.copy(position);
            
            // é‡ç½®ç²’å­ä½ç½®
            const pos = explosionSystem.geometry.attributes.position.array;
            for(let i=0; i<pos.length; i+=3) {
                pos[i] = 0;
                pos[i+1] = 0;
                pos[i+2] = 0;
            }
            explosionSystem.geometry.attributes.position.needsUpdate = true;
            explosionSystem.material.opacity = 1;
        }

        function updateExplosion(dt) {
            if(!state.explosionActive) return;
            
            state.explosionTime += dt;
            const duration = 3.0; // å»¶é•¿çˆ†ç‚¸æŒç»­æ—¶é—´
            
            if(state.explosionTime > duration) {
                state.explosionActive = false;
                explosionSystem.visible = false;
                return;
            }

            const pos = explosionSystem.geometry.attributes.position.array;
            const colors = explosionSystem.geometry.attributes.color.array;
            const sizes = explosionSystem.geometry.attributes.size.array;
            const vels = explosionSystem.geometry.userData.velocities;
            const progress = state.explosionTime / duration;
            
            for(let i=0; i<pos.length/3; i++) {
                // ç‰©ç†æ¨¡æ‹Ÿï¼šé€Ÿåº¦ + é‡åŠ› + èºæ—‹
                const gravity = -3;
                const spiral = Math.sin(state.explosionTime * 5 + i) * 0.5;
                
                pos[i*3] += vels[i].x * dt + spiral * dt;
                pos[i*3+1] += vels[i].y * dt + gravity * dt * state.explosionTime;
                pos[i*3+2] += vels[i].z * dt;
                
                // é˜»åŠ›
                vels[i].x *= 0.97;
                vels[i].y *= 0.97;
                vels[i].z *= 0.97;
                
                // åŠ¨æ€é¢œè‰²å˜åŒ–ï¼ˆå½©è™¹æ•ˆæœï¼‰
                const hue = (i / (pos.length/3) + state.explosionTime * 0.5) % 1.0;
                const c = new THREE.Color().setHSL(hue, 1.0, 0.6);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
                
                // ç²’å­å¤§å°å˜åŒ–ï¼ˆå…ˆå¤§åå°ï¼‰
                const sizeProgress = Math.sin(progress * Math.PI);
                sizes[i] = (Math.random() * 0.1 + 0.05) * sizeProgress;
            }
            
            explosionSystem.geometry.attributes.position.needsUpdate = true;
            explosionSystem.geometry.attributes.color.needsUpdate = true;
            explosionSystem.geometry.attributes.size.needsUpdate = true;
            
            // æ·¡å‡ºæ•ˆæœï¼ˆæ›´å¹³æ»‘ï¼‰
            explosionSystem.material.opacity = Math.pow(1 - progress, 2);
        }

        // æ”¹è¿›çš„çº¹ç†ç”Ÿæˆï¼šæ˜Ÿæ˜Ÿå½¢çŠ¶
        function createGlowTexture(isStar = false) {
            const c = document.createElement('canvas');
            c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            
            if(isStar) {
                // ç»˜åˆ¶åå­—æ˜Ÿå…‰
                const cx = 32, cy = 32;
                const g = ctx.createRadialGradient(cx,cy,0,cx,cy,32);
                g.addColorStop(0,'rgba(255,255,255,1)');
                g.addColorStop(0.2,'rgba(255,255,255,0.8)');
                g.addColorStop(0.5,'rgba(255,255,255,0.2)');
                g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=g;
                ctx.fillRect(0,0,64,64);
                
                // åå­—å…‰èŠ’
                ctx.beginPath();
                ctx.moveTo(cx, 0); ctx.lineTo(cx, 64);
                ctx.moveTo(0, cy); ctx.lineTo(64, cy);
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                // æŸ”å’Œå…‰ç‚¹
                const g = ctx.createRadialGradient(32,32,0,32,32,32);
                g.addColorStop(0,'rgba(255,255,255,1)');
                g.addColorStop(0.3,'rgba(255,255,255,0.5)');
                g.addColorStop(0.7,'rgba(255,255,255,0.1)');
                g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=g;
                ctx.fillRect(0,0,64,64);
            }
            
            const t = new THREE.Texture(c);
            t.needsUpdate=true;
            return t;
        }

        // --- Vision & Gestures ---
        async function waitForLibs() {
            while(!window.Hands || !window.Camera) await new Promise(r=>setTimeout(r,100));
        }

        async function initVision() {
            const video = document.getElementById('video-feed');
            const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults(handleGestures);
            
            const cam = new Camera(video, {
                onFrame: async()=>{ await hands.send({image:video}); },
                width: 640, height: 480
            });
            cam.start();
        }

        let lastGesture = '';
        let gestureStartTime = 0;
        let lastEncouragementTime = 0;
        
        function handleGestures(results) {
            const statusLight = document.getElementById('status-light');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusLight.classList.add('active');
                state.hasHand = true;
                
                const lm = results.multiHandLandmarks[0];
                const wrist = lm[0];

                // --- æ‰‹éƒ¨ä½ç½®è·Ÿè¸ªï¼ˆä¸æ»‘ï¼‰ ---
                const ndcX = (1 - lm[9].x) * 2 - 1;
                const ndcY = -(lm[9].y * 2 - 1);
                
                const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                // è®¡ç®—é€Ÿåº¦ï¼ˆç”¨äºçˆ†ç‚¸æ•ˆæœï¼‰
                state.handVelocity.subVectors(pos, state.lastHandPos);
                state.lastHandPos.copy(state.handPos);
                
                // æ›´å¹³æ»‘çš„æ’å€¼
                state.handPos.lerp(pos, 0.15);

                // --- è®¡ç®—ç³»ç»Ÿæ•´ä½“æ—‹è½¬ï¼ˆåŸºäºæ‰‹çš„ç§»åŠ¨æ–¹å‘ï¼‰ ---
                if(state.handVelocity.length() > 0.01) {
                    const angle = Math.atan2(state.handVelocity.y, state.handVelocity.x);
                    state.targetSystemRotation = angle * 0.5; // å¢å¼ºæ—‹è½¬æ•ˆæœ
                } else {
                    // æ²¡æœ‰ç§»åŠ¨æ—¶é€æ¸å›åˆ°åŸä½
                    state.targetSystemRotation *= 0.95;
                }

                // --- æ”¹è¿›çš„æ‰‹åŠ¿è¯†åˆ« ---
                // è®¡ç®—æ‰‹æŒ‡å¼ å¼€ç¨‹åº¦
                const tips = [8, 12, 16, 20]; // é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡
                let totalSpread = 0;
                tips.forEach(i => {
                    totalSpread += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y);
                });
                const avgSpread = totalSpread / 4;

                // --- æ”¹è¿›çš„æ‰‹åŠ¿è¯†åˆ« (å‡ ä½•ç‰¹å¾æ³•) ---
                
                // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´
                // é€»è¾‘ï¼šæŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»æ˜¾è‘—å¤§äºç¬¬äºŒå…³èŠ‚(PIP)åˆ°æ‰‹è…•çš„è·ç¦»
                const isFingerExtended = (tipId, pipId) => {
                     const dTip = Math.hypot(lm[tipId].x - wrist.x, lm[tipId].y - wrist.y);
                     const dPip = Math.hypot(lm[pipId].x - wrist.x, lm[pipId].y - wrist.y);
                     return dTip > dPip * 1.2; // 1.2å€é˜ˆå€¼ï¼Œç¡®ä¿æ˜æ˜¾ä¼¸ç›´
                };

                // æ£€æµ‹å„æ‰‹æŒ‡çŠ¶æ€ (Thumb:4, Index:8, Middle:12, Ring:16, Pinky:20)
                // å…³èŠ‚ç´¢å¼•: Index(6), Middle(10), Ring(14), Pinky(18)
                const indexExt = isFingerExtended(8, 6);
                const middleExt = isFingerExtended(12, 10);
                const ringExt = isFingerExtended(16, 14);
                const pinkyExt = isFingerExtended(20, 18);
                
                // è®¡ç®—é£ŸæŒ‡å’Œä¸­æŒ‡æŒ‡å°–è·ç¦» (Vå­—æ£€æµ‹)
                const vDist = Math.hypot(lm[8].x - lm[12].x, lm[8].y - lm[12].y);
                const isV = vDist > 0.05; // ç¡®ä¿ä¸¤æŒ‡åˆ†å¼€

                let gesture = 'idle';
                
                // Peace Sign (å‰ªåˆ€æ‰‹) åˆ¤å®šæ¡ä»¶ï¼š
                // 1. é£ŸæŒ‡ä¼¸ç›´
                // 2. ä¸­æŒ‡ä¼¸ç›´
                // 3. æ— åæŒ‡å¼¯æ›² (å…³é”®åŒºåˆ†ç‚¹)
                // 4. å°æŒ‡å¼¯æ›² (å…³é”®åŒºåˆ†ç‚¹)
                // 5. é£ŸæŒ‡ä¸­æŒ‡åˆ†å¼€ (Vå­—)
                const isPeace = indexExt && middleExt && !ringExt && !pinkyExt && isV;
                
                // è°ƒè¯•ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
                if(window.debugGesture) {
                    console.log({
                        indexExt, middleExt, ringExt, pinkyExt,
                        vDist: vDist.toFixed(3),
                        isPeace
                    });
                }
                
                if (isPeace) {
                    gesture = 'peace';
                    state.targetDispersion = 3.0;
                    state.targetZoom = 1.0;
                    
                    // Peaceæ‰‹åŠ¿æ—¶100%è§¦å‘é¼“åŠ±
                    // ä½†è¿™é‡Œæˆ‘ä»¬ç”¨è‡ªå®šä¹‰çš„çˆ±å¿ƒæ–‡å­—ï¼Œæ‰€ä»¥æ³¨é‡Šæ‰éšæœºencouragement
                    // const msg = ANTHONY_QUOTES[Math.floor(Math.random()*ANTHONY_QUOTES.length)];
                    // const el = document.getElementById('msg-text');
                    // el.innerText = msg;
                    // el.classList.add('show');
                    // setTimeout(()=>el.classList.remove('show'), 2500);
                    
                    if (lastGesture !== 'peace') {
                        
                        // çƒŸèŠ±éŸ³æ•ˆï¼šä¸Šå‡éŸ³é˜¶ + å’Œå¼¦çˆ†ç‚¸
                        playMelody([
                            {freq: 523.25, duration: 0.1, type: 'sine'},  // C5
                            {freq: 659.25, duration: 0.1, type: 'sine'},  // E5
                            {freq: 783.99, duration: 0.15, type: 'sine'}, // G5
                            {freq: 1046.5, duration: 0.2, type: 'triangle'} // C6
                        ], 80);
                        
                        // æ˜¾ç¤ºç‰¹åˆ«çš„çˆ±å¿ƒæ–‡å­—
                        const el = document.getElementById('msg-text');
                        el.innerHTML = "yuqi always love Anthony â¤ï¸<br>yuqi always love Anthony â¤ï¸<br>yuqi always love Anthony â¤ï¸";
                        el.style.fontFamily = "'Brush Script MT', cursive"; // hand-written style
                        el.style.lineHeight = "1.5";
                        el.classList.add('show');
                        // Keep showing until gesture ends
                        
                        // çˆ†ç‚¸å’Œå¼¦
                        setTimeout(() => {
                            playChord([523.25, 659.25, 783.99, 1046.5], 0.5, 'triangle');
                        }, 350);
                        
                        // åœ¨æ‰‹éƒ¨ä½ç½®è§¦å‘çˆ†ç‚¸
                        triggerExplosion(state.handPos.clone());
                        
                        // è§¦å‘å±å¹•éœ‡åŠ¨
                        screenShake = 1.0;
                        
                        // éšæœºé¢œè‰²çˆ†å‘
                        const colors = diamondSystem.geometry.attributes.color.array;
                        for(let i=0; i<colors.length; i+=3) {
                            if(colors[i] < 0.9) {
                                const hue = Math.random();
                                const c = new THREE.Color().setHSL(hue, 0.8, 0.6);
                                colors[i] = c.r;
                                colors[i+1] = c.g;
                                colors[i+2] = c.b;
                            }
                        }
                        diamondSystem.geometry.attributes.color.needsUpdate = true;
                    }
                }
                // æ¡æ‹³ - ç²’å­ç¼©å°
                else if (avgSpread < 0.25) {
                    gesture = 'fist';
                    state.targetHandSpread = 0;
                    state.targetParticleScale = 0.3; // ç¼©å°åˆ°30%
                    if (lastGesture !== 'fist') {
                        triggerEncouragement();
                        playTone(392, 0.2, 'sine'); // G4
                    }
                }
                // å¼ å¼€ - ç²’å­æ”¾å¤§
                else if (avgSpread > 0.4) {
                    gesture = 'open';
                    state.targetHandSpread = 1;
                    state.targetParticleScale = 1.5; // æ”¾å¤§åˆ°150%
                    if (lastGesture !== 'open') {
                        triggerEncouragement();
                        playTone(523.25, 0.2, 'sine'); // C5
                    }
                } 
                else {
                    // ä¸­é—´çŠ¶æ€
                    state.targetHandSpread = 0.5;
                    state.targetParticleScale = 1.0;
                }
                
                state.targetRot = (lm[9].x - 0.5) * 3;
                lastGesture = gesture;
                
                // æ›´æ–°æ‰‹åŠ¿æŒ‡ç¤ºå™¨
                const gestureEl = document.getElementById('current-gesture');
                if(gestureEl) {
                    const gestureNames = {
                        'peace': 'âœŒï¸ Peace',
                        'fist': 'ğŸ‘Š Fist',
                        'open': 'âœ‹ Open',
                        'idle': 'Idle'
                    };
                    gestureEl.textContent = gestureNames[gesture] || gesture;
                    gestureEl.style.color = gesture === 'peace' ? '#FF1493' : 
                                           gesture === 'fist' ? '#FF69B4' :
                                           gesture === 'open' ? '#FFB6C1' : '#FF69B4';
                }

            } else {
                statusLight.classList.remove('active');
                state.hasHand = false;
                state.targetHandSpread = 0.5;
                state.targetParticleScale = 1.0;
                state.targetDispersion = 0.05;
                state.targetRot = 0;
                
                // ç¡®ä¿æ–‡å­—æ¶ˆå¤±
                document.getElementById('msg-text').classList.remove('show');
                
                // æ›´æ–°æ‰‹åŠ¿æŒ‡ç¤ºå™¨
                const gestureEl = document.getElementById('current-gesture');
                if(gestureEl) {
                    gestureEl.textContent = 'No hand detected';
                    gestureEl.style.color = '#666';
                }
            }
        }

        function triggerEncouragement() {
            if (Math.random() > 0.2) return; // 80%çš„è§¦å‘æ¦‚ç‡ï¼Œè®©é¼“åŠ±æ›´é¢‘ç¹
            const msg = ANTHONY_QUOTES[Math.floor(Math.random()*ANTHONY_QUOTES.length)];
            const el = document.getElementById('msg-text');
            el.innerText = msg;
            el.classList.add('show');
            setTimeout(()=>el.classList.remove('show'), 2500);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();
            const smoothFactor = 6.0 * dt; // æ›´é«˜çš„å¹³æ»‘å› å­ï¼Œæ›´ä¸æ»‘

            // è¶…ä¸æ»‘çš„çŠ¶æ€è¿‡æ¸¡
            state.handSpread += (state.targetHandSpread - state.handSpread) * smoothFactor;
            state.particleScale += (state.targetParticleScale - state.particleScale) * smoothFactor;
            state.dispersion += (state.targetDispersion - state.dispersion) * smoothFactor;
            state.zoom += (state.targetZoom - state.zoom) * smoothFactor;
            state.rotationOffset += (state.targetRot - state.rotationOffset) * smoothFactor;
            state.systemRotation += (state.targetSystemRotation - state.systemRotation) * smoothFactor;

            // ç²’å­ç³»ç»Ÿæ•´ä½“ä½ç½®è·Ÿéšæ‰‹éƒ¨ï¼ˆé™ä½é€Ÿåº¦ï¼Œé˜²æ­¢è·‘å‡ºå±å¹•ï¼‰
            if(state.hasHand) {
                // é™åˆ¶æ‰‹éƒ¨ä½ç½®åœ¨åˆç†èŒƒå›´å†…
                const clampedHandPos = state.handPos.clone();
                clampedHandPos.x = THREE.MathUtils.clamp(clampedHandPos.x, -5, 5);
                clampedHandPos.y = THREE.MathUtils.clamp(clampedHandPos.y, -3, 3);
                clampedHandPos.z = THREE.MathUtils.clamp(clampedHandPos.z, -2, 2);
                
                state.systemPosition.lerp(clampedHandPos, 0.06); // é™ä½è·Ÿéšé€Ÿåº¦
            } else {
                state.systemPosition.lerp(new THREE.Vector3(0,0,0), 0.05);
            }

            const targetZ = 10 / state.zoom;
            camera.position.z += (targetZ - camera.position.z) * 0.08;

            scene.rotation.y += 0.002;
            scene.rotation.y += state.rotationOffset * 0.03;

            updateParticles(dt);
            updateExplosion(dt);
            updateTrailSystem();
            updateSpiritSystem(dt, clock.getElapsedTime()); // æ›´æ–°çµåŠ¨å°˜åŸƒ
            updateHandAura(dt); // æ›´æ–°æ‰‹éƒ¨å…‰ç¯
            // updateHeartRings(clock.getElapsedTime()); 
            updateHeartExplosion(dt, clock.getElapsedTime()); // æ›´æ–°çˆ±å¿ƒçˆ†ç‚¸
            updateStarField(clock.getElapsedTime());
            updateShockwave(dt);
            updateMinimap(); // æ›´æ–°å°åœ°å›¾
            
            // å±å¹•éœ‡åŠ¨æ•ˆæœ
            if(screenShake > 0) {
                const shakeAmount = screenShake * 0.3;
                camera.position.x += (Math.random() - 0.5) * shakeAmount;
                camera.position.y += (Math.random() - 0.5) * shakeAmount;
                screenShake *= 0.92; // è¡°å‡
                if(screenShake < 0.01) screenShake = 0;
            }
            
            // å®šæœŸè§¦å‘é¼“åŠ±ä¿¡æ¯ï¼ˆæ‰‹éƒ¨æ´»è·ƒæ—¶ï¼‰
            const currentTime = clock.getElapsedTime();
            if (state.hasHand && state.handVelocity.length() > 0.05 && 
                currentTime - lastEncouragementTime > 5) {
                lastEncouragementTime = currentTime;
                if (Math.random() > 0.5) {
                    const msg = ANTHONY_QUOTES[Math.floor(Math.random()*ANTHONY_QUOTES.length)];
                    const el = document.getElementById('msg-text');
                    el.innerText = msg;
                    el.classList.add('show');
                    setTimeout(()=>el.classList.remove('show'), 2500);
                }
            }
            
            // æ›´æ–°äº¤äº’æç¤º
            updateInteractionHint();
            
            controls.update();
            composer.render();
        }

        // --- æ›´æ–°äº¤äº’æç¤º ---
        function updateInteractionHint() {
            const hintEl = document.getElementById('interaction-hint');
            const hintText = document.getElementById('hint-text');
            
            if(bigPicturePlane && bigPicturePlane.visible && state.hasHand) {
                hintEl.style.opacity = '1';
                
                if(state.handNearPicture) {
                    hintText.innerHTML = '<i class="fas fa-star" style="color:#FF1493;"></i> Photo interaction active!';
                    hintEl.style.background = 'rgba(255,105,180,0.2)';
                    hintEl.classList.add('active');
                } else {
                    hintText.innerHTML = 'Move your hand closer to the photo';
                    hintEl.style.background = 'rgba(255,105,180,0.1)';
                    hintEl.classList.remove('active');
                }
            } else if(bigPicturePlane && bigPicturePlane.visible) {
                hintEl.style.opacity = '1';
                hintText.innerHTML = 'Raise your hand to start interaction';
                hintEl.style.background = 'rgba(255,105,180,0.1)';
                hintEl.classList.remove('active');
            } else {
                hintEl.style.opacity = '0';
                hintEl.classList.remove('active');
            }
        }

        function updateParticles(dt) {
            if(!diamondSystem || !photoSystem) return;
            
            const time = clock.getElapsedTime();
            const breath = Math.sin(time * 2) * 0.03;

            // 1. æ›´æ–°å°˜åŸƒç²’å­ - è·Ÿéšæ‰‹ç§»åŠ¨å’Œæ—‹è½¬
            const pos = diamondSystem.geometry.attributes.position.array;
            const orig = diamondSystem.geometry.userData.original;
            const colors = diamondSystem.geometry.attributes.color.array;
            const sizes = diamondSystem.geometry.attributes.size.array;
            const origColors = diamondSystem.geometry.userData.originalColors;
            
            // --- å…³é”®ä¿®æ”¹ï¼šæ•´ä½“ç§»åŠ¨ç²’å­ç³»ç»Ÿ ---
            diamondSystem.position.copy(state.systemPosition);
            
            // åˆ›å»ºæ—‹è½¬çŸ©é˜µ
            const cos = Math.cos(state.systemRotation);
            const sin = Math.sin(state.systemRotation);
            
            // ç²’å­é¢œè‰²è„‰å†²ï¼ˆæ ¹æ®æ‰‹éƒ¨é€Ÿåº¦ï¼‰
            const speedFactor = state.handVelocity.length() * 2;
            const colorPulse = Math.sin(time * 4) * 0.2;
            
            // é¢„è®¡ç®—æ¼©æ¶¡å‚æ•° (å½“æ‰‹å­˜åœ¨æ—¶)
            const handLocalX = state.handPos.x - state.systemPosition.x;
            const handLocalY = state.handPos.y - state.systemPosition.y;
            const swirlStrength = state.hasHand ? 1.0 : 0;
            
            for(let i=0; i<pos.length; i+=3) {
                const ox = orig[i];
                const oy = orig[i+1];
                const oz = orig[i+2];

                const dist = Math.sqrt(ox*ox + oy*oy + oz*oz);
                const nx = ox/dist; const ny = oy/dist; const nz = oz/dist;
                
                // åŠ¨æ€æ‰©æ•£ï¼ˆå¸¦å™ªå£°ï¼‰
                const noise = Math.sin(ox*8 + time*2) * Math.cos(oy*8 + time*1.5);
                const expansion = state.dispersion * (6 + noise * 2);

                // åº”ç”¨ç²’å­ç¼©æ”¾ï¼ˆæ¡æ‹³/å¼ å¼€æ•ˆæœï¼‰
                let tx = (ox + nx * (expansion + breath)) * state.particleScale;
                let ty = (oy + ny * (expansion + breath)) * state.particleScale;
                let tz = (oz + nz * (expansion + breath)) * state.particleScale;

                // --- æå…‰æµåŠ¨æ•ˆæœ (Aurora Flow) ---
                // å³ä½¿é™æ­¢æ—¶ä¹Ÿä¿æŒä¼˜é›…çš„æµåŠ¨
                tx += Math.sin(ty * 2 + time) * 0.05;
                ty += Math.cos(tx * 2 + time * 0.8) * 0.05;

                // --- èƒ½é‡æ¼©æ¶¡æ•ˆæœ (Energy Vortex) ---
                // å½“æ‰‹é è¿‘æ—¶ï¼Œç²’å­ä¼šå—åˆ°æ—‹è½¬åŠ›çš„å½±å“
                if (swirlStrength > 0) {
                    const dx = tx - handLocalX;
                    const dy = ty - handLocalY;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if(d < 3.0) { // 3ä¸ªå•ä½åŠå¾„å†…çš„ç²’å­
                        const angle = Math.atan2(dy, dx);
                        const force = (3.0 - d) * 0.02; // è·ç¦»è¶Šè¿‘æ—‹è½¬è¶Šå¿«
                        
                        // æ–½åŠ åˆ‡å‘åŠ› (æ—‹è½¬)
                        tx += -Math.sin(angle) * force; // è¿™é‡Œå®é™…ä¸Šæ˜¯ç®€å•çš„åç§»ï¼Œä¸ºäº†æ€§èƒ½ä¸ç”¨çœŸæ­£çš„ç‰©ç†ç§¯åˆ†
                        ty += Math.cos(angle) * force;
                        
                        // æ–½åŠ è½»å¾®çš„å¸å¼•åŠ›
                        tx -= dx * 0.01;
                        ty -= dy * 0.01;
                    }
                }

                // --- åº”ç”¨æ—‹è½¬ ---
                const rtx = tx * cos - ty * sin;
                const rty = tx * sin + ty * cos;
                tx = rtx;
                ty = rty;

                // å¹³æ»‘è¿‡æ¸¡
                pos[i] += (tx - pos[i]) * 0.1;
                pos[i+1] += (ty - pos[i+1]) * 0.1;
                pos[i+2] += (tz - pos[i+2]) * 0.1;
                
                // åŠ¨æ€é¢œè‰²å˜åŒ– (å¹»å½©æå…‰)
                if(origColors && colors[i] < 0.9) { 
                    const idx = i / 3;
                    // åŸºäºä½ç½®å’Œæ—¶é—´çš„è‰²å½©åç§»
                    const posHue = (tx * 0.1 + ty * 0.1 + time * 0.05) % 1.0;
                    
                    const c = new THREE.Color(origColors[i], origColors[i+1], origColors[i+2]);
                    // æ··åˆé‡‘è‰²ä¸æ·±ç©ºè“/ç´«
                    const mixColor = new THREE.Color().setHSL(0.6 + posHue * 0.2, 0.8, 0.6);
                    c.lerp(mixColor, 0.3 + speedFactor * 0.2); // é€Ÿåº¦è¶Šå¿«é¢œè‰²è¶Šç»šä¸½
                    
                    colors[i] = c.r;
                    colors[i+1] = c.g;
                    colors[i+2] = c.b;
                }
                
                // åŠ¨æ€å¤§å°å˜åŒ–ï¼ˆå‘¼å¸æ•ˆæœï¼‰
                if(sizes[i/3]) {
                    const sizeWave = Math.sin(time * 3 + i * 0.05) * 0.02;
                    sizes[i/3] = Math.max(0.01, sizes[i/3] + sizeWave);
                }
            }
            diamondSystem.geometry.attributes.position.needsUpdate = true;
            diamondSystem.geometry.attributes.color.needsUpdate = true;
            diamondSystem.geometry.attributes.size.needsUpdate = true;

            // 2. æ›´æ–°ç…§ç‰‡ç²’å­ - åŒæ ·åº”ç”¨æ—‹è½¬å’Œä½ç½®åç§»
            const dummy = new THREE.Object3D();
            const pOrig = photoSystem.userData.original;
            
            // è¿™é‡Œçš„systemPositionä¹Ÿé€šè¿‡dummy positionæˆ–è€…å¤–å±‚å®¹å™¨æ¥å¤„ç†
            // ä½†InstancedMeshæ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬è¿™é‡Œç›´æ¥åŠ ä¸Šåç§»é‡æˆ–è€…å°†photoSystemæ”¾å…¥ä¸€ä¸ªGroupä¸­
            // ä¸ºäº†ç®€å•ä¸”ä¸€è‡´ï¼Œæˆ‘ä»¬ä¹Ÿç§»åŠ¨photoSystemçš„ä½ç½®
            photoSystem.position.copy(state.systemPosition);
            
            for(let i=0; i<photoSystem.userData.count; i++) {
                const ox = pOrig[i*3];
                const oy = pOrig[i*3+1];
                const oz = pOrig[i*3+2];
                
                const photoDist = Math.sqrt(ox*ox + oy*oy + oz*oz);
                const expansion = state.dispersion * (8 + Math.cos(oy*6 + time)*3);

                // åº”ç”¨ç²’å­ç¼©æ”¾
                let tx = (ox + (ox/photoDist) * (expansion + breath)) * state.particleScale;
                let ty = (oy + (oy/photoDist) * (expansion + breath)) * state.particleScale;
                let tz = (oz + (oz/photoDist) * (expansion + breath)) * state.particleScale;

                // --- åº”ç”¨æ—‹è½¬ ---
                const rtx = tx * cos - ty * sin;
                const rty = tx * sin + ty * cos;
                tx = rtx;
                ty = rty;

                dummy.position.set(tx, ty, tz);
                
                const s = 1 + state.dispersion * 2; 
                dummy.scale.set(s,s,s);
                dummy.lookAt(camera.position);
                dummy.updateMatrix();
                photoSystem.setMatrixAt(i, dummy.matrix);
            }
            photoSystem.instanceMatrix.needsUpdate = true;

            // 3. å¤§å›¾ç‰‡å¹³é¢ - æ”¹è¿›æ˜¾ç¤ºé€»è¾‘å’ŒåŠ¨ç”»
            if (bigPicturePlane && bigPicturePlane.material.map) {
                const isFireworks = state.dispersion > 2.5;
                const isPinch = state.zoom > 1.8;
                
                // æ˜¾ç¤ºæ¡ä»¶
                const targetOpacity = (isPinch || isFireworks) ? 1.0 : 0;
                const wasInvisible = bigPicturePlane.material.opacity < 0.01;
                bigPicturePlane.material.opacity += (targetOpacity - bigPicturePlane.material.opacity) * 0.1;
                bigPicturePlane.visible = bigPicturePlane.material.opacity > 0.01;
                
                    // Fireworksæ—¶å…³é—­bloomæ•ˆæœ
                    if(isFireworks) {
                        if(window.bloomPass) {
                            window.bloomPass.enabled = false;
                        }
                        bigPicturePlane.material.blending = THREE.NormalBlending; // æ­£å¸¸æ··åˆï¼Œæ— å‘å…‰
                        
                        // å¼ºåˆ¶æ›´æ–°æè´¨ä»¥ç¡®ä¿æ— å…‰æ•ˆ
                        bigPicturePlane.material.needsUpdate = true;
                        
                        // å…¨å±æ˜¾ç¤ºé€»è¾‘æ›´æ–°ï¼šCONTAIN ä½†ç¡®ä¿æœ€å¤§åŒ–
                        const vFOV = THREE.MathUtils.degToRad(camera.fov);
                        const distance = Math.abs(camera.position.z - bigPicturePlane.position.z);
                        const viewHeight = 2 * Math.tan(vFOV / 2) * distance;
                        const viewWidth = viewHeight * camera.aspect;
                        
                        if(imageAspectRatio) {
                            const screenAspect = camera.aspect;
                            let finalWidth, finalHeight;
                            
                            // é€»è¾‘ï¼šCONTAIN (ä¿è¯å›¾ç‰‡å®Œå…¨æ˜¾ç¤º)
                            if(imageAspectRatio > screenAspect) {
                                // å›¾ç‰‡æ›´å®½ -> å®½åº¦æ’‘æ»¡ï¼Œé«˜åº¦è‡ªé€‚åº” (ä¼šæœ‰ä¸Šä¸‹ç•™ç™½)
                                finalWidth = viewWidth;
                                finalHeight = finalWidth / imageAspectRatio;
                            } else {
                                // å›¾ç‰‡æ›´é«˜ -> é«˜åº¦æ’‘æ»¡ï¼Œå®½åº¦è‡ªé€‚åº” (ä¼šæœ‰å·¦å³ç•™ç™½)
                                finalHeight = viewHeight;
                                finalWidth = finalHeight * imageAspectRatio;
                            }
                            
                            bigPicturePlane.scale.set(finalWidth, finalHeight, 1);
                        }
                        
                        // å±…ä¸­æ˜¾ç¤ºï¼Œæ— æµ®åŠ¨
                        bigPicturePlane.position.set(0, 0, 3);
                        
                        // --- éšè—/ä¿®æ”¹å¹²æ‰°å…ƒç´  ---
                        if(handAuraSystem) handAuraSystem.visible = false; // éšè—æ‰‹éƒ¨å…‰ç¯
                        if(shockwave) shockwave.visible = false; // éšè—å†²å‡»æ³¢
                        if(diamondSystem) diamondSystem.visible = false; // éšè—èƒŒæ™¯å°˜åŸƒ
                        if(trailSystem) trailSystem.visible = false; // éšè—ç»¿è‰²/é’è‰²æ‰‹éƒ¨è½¨è¿¹
                        if(explosionSystem) explosionSystem.visible = false; // éšè—é‚£ä¸ªè¯¥æ­»çš„ç»¿è‰²çˆ†ç‚¸æ³¢ï¼ï¼ï¼
                        if(photoSystem) photoSystem.visible = false; // éšè—ç…§ç‰‡ç²’å­
                        if(pictureFrame) pictureFrame.visible = false; // éšè—è¾¹æ¡†
                        if(spiritSystem) spiritSystem.visible = false; // éšè—çµåŠ¨å°˜åŸƒ
                        if(lightRings) { // éšè—ç»¿è‰²å…‰ç¯
                            lightRings.forEach(ring => {
                                ring.material.opacity = 0;
                                ring.visible = false;
                            });
                        }
                        
                        // èƒŒæ™¯é¢œè‰²è°ƒæ•´ä¸ºæ·±è‰²ä»¥çªå‡ºçˆ±å¿ƒ
                        scene.background = new THREE.Color(0x000000);
                        scene.fog.color.setHex(0x000000);

                    } else {
                        // æ¢å¤æ­£å¸¸çŠ¶æ€
                        if(window.bloomPass) window.bloomPass.enabled = true;
                        if(handAuraSystem) handAuraSystem.visible = true;
                        if(diamondSystem) diamondSystem.visible = true;
                        if(trailSystem) trailSystem.visible = true;
                        if(photoSystem) photoSystem.visible = true;
                        if(spiritSystem) spiritSystem.visible = true;
                        if(lightRings) { // æ¢å¤å…‰ç¯ï¼ˆä½†ä¼šåœ¨updateLightRingsä¸­æ ¹æ®æ¡ä»¶æ˜¾ç¤ºï¼‰
                            lightRings.forEach(ring => {
                                ring.visible = true;
                            });
                        }
                        scene.background = null; // é€æ˜/é»˜è®¤
                        scene.fog.color.setHex(CONFIG.bgColor);
                        // ... (åŸæœ‰çš„éFireworksé€»è¾‘ä¿æŒä¸å˜)
                    // éFireworksæ—¶æ¢å¤bloom
                    if(window.bloomPass) {
                        window.bloomPass.enabled = true;
                    }
                    bigPicturePlane.material.blending = THREE.NormalBlending;
                    
                    // å…¥åœºåŠ¨ç”»ï¼šæ—‹è½¬å’Œç¼©æ”¾
                    if(bigPicturePlane.visible && wasInvisible) {
                        state.targetPictureRotation = Math.PI * 2;
                    }
                    
                    // å¹³æ»‘æ—‹è½¬
                    state.pictureRotation += (state.targetPictureRotation - state.pictureRotation) * 0.08;
                    if(Math.abs(state.pictureRotation - state.targetPictureRotation) < 0.01) {
                        state.targetPictureRotation = 0;
                        state.pictureRotation = 0;
                    }
                    
                    // ä¼˜é›…çš„æµ®åŠ¨æ•ˆæœ
                    bigPicturePlane.position.y = Math.sin(time * 0.5) * 0.3;
                    bigPicturePlane.position.x = Math.cos(time * 0.3) * 0.1;
                    bigPicturePlane.position.z = 3;
                    
                    // æ­£å¸¸å°ºå¯¸ï¼ˆ80%è§†å£ï¼‰
                    if(imageAspectRatio) {
                        const tempW = 1000, tempH = 1000 / imageAspectRatio;
                        const size = calculateFitSize(tempW, tempH, camera.position.z);
                        bigPicturePlane.scale.set(size.width, size.height, 1);
                    }
                }
                
                // å§‹ç»ˆé¢å‘ç›¸æœº
                bigPicturePlane.lookAt(camera.position);
                if(!isFireworks) {
                    bigPicturePlane.rotateZ(state.pictureRotation);
                }
            }

            // 4. æ‰‹ä¸å›¾ç‰‡çš„äº¤äº’æ£€æµ‹
            if(state.hasHand && bigPicturePlane.visible) {
                const distToPicture = state.handPos.distanceTo(bigPicturePlane.position);
                state.handNearPicture = distToPicture < 4;
                
                // æ‰‹é è¿‘æ—¶å›¾ç‰‡ç¼©æ”¾
                const targetScale = state.handNearPicture ? 1.15 : 1.0;
                state.pictureScale += (targetScale - state.pictureScale) * 0.08;
                
                // åº”ç”¨ç¼©æ”¾
                const currentScale = bigPicturePlane.scale.clone();
                bigPicturePlane.scale.multiplyScalar(state.pictureScale);
            } else {
                state.handNearPicture = false;
                state.pictureScale += (1.0 - state.pictureScale) * 0.08;
            }

            // 5. å›¾ç‰‡è¾¹æ¡†ç²’å­åŠ¨ç”»
            if (pictureFrame && bigPicturePlane.visible) {
                pictureFrame.visible = true;
                
                // æ‰‹é è¿‘æ—¶è¾¹æ¡†æ›´äº®
                const targetOpacity = state.handNearPicture ? 1.0 : 0.7;
                pictureFrame.material.opacity += (targetOpacity - pictureFrame.material.opacity) * 0.1;
                
                // åŒæ­¥ä½ç½®å’Œæœå‘
                pictureFrame.position.copy(bigPicturePlane.position);
                pictureFrame.position.z += 0.1;
                pictureFrame.lookAt(camera.position);
                
                // åŒæ­¥ç¼©æ”¾
                pictureFrame.scale.copy(bigPicturePlane.scale);
                
                // è¾¹æ¡†ç²’å­åŠ¨ç”»
                const framePos = pictureFrame.geometry.attributes.position.array;
                const frameColors = pictureFrame.geometry.attributes.color.array;
                const frameSizes = pictureFrame.geometry.attributes.size.array;
                
                for(let i = 0; i < framePos.length/3; i++) {
                    const idx = i * 3;
                    
                    // åŸºç¡€è„‰å†²
                    const pulse = Math.sin(time * 3 + i * 0.1) * 0.05;
                    
                    // æ‰‹é è¿‘æ—¶çš„é¢å¤–æ•ˆæœ
                    const nearEffect = state.handNearPicture ? Math.sin(time * 8 + i * 0.2) * 0.08 : 0;
                    
                    const x = framePos[idx];
                    const y = framePos[idx+1];
                    
                    framePos[idx] = x * (1 + pulse + nearEffect);
                    framePos[idx+1] = y * (1 + pulse + nearEffect);
                    
                    // åŠ¨æ€é¢œè‰²
                    const hue = state.handNearPicture ? 
                        0.15 + Math.sin(time * 4 + i * 0.1) * 0.1 : 
                        0.12 + Math.sin(time * 2 + i * 0.05) * 0.05;
                    const brightness = state.handNearPicture ? 0.7 : 0.6;
                    const c = new THREE.Color().setHSL(hue, 0.9, brightness + pulse);
                    frameColors[idx] = c.r;
                    frameColors[idx+1] = c.g;
                    frameColors[idx+2] = c.b;
                    
                    // æ‰‹é è¿‘æ—¶ç²’å­å˜å¤§
                    frameSizes[i] = (state.handNearPicture ? 0.08 : 0.05) + Math.abs(pulse) * 0.02;
                }
                
                pictureFrame.geometry.attributes.position.needsUpdate = true;
                pictureFrame.geometry.attributes.color.needsUpdate = true;
                pictureFrame.geometry.attributes.size.needsUpdate = true;
            } else if(pictureFrame) {
                pictureFrame.material.opacity += (0 - pictureFrame.material.opacity) * 0.1;
                if(pictureFrame.material.opacity < 0.01) {
                    pictureFrame.visible = false;
                }
            }
        }

        // --- UI Events ---
        function setupEvents() {
            document.getElementById('color-picker').addEventListener('input', (e)=>{
                const c = new THREE.Color(e.target.value);
                state.baseColor.copy(c);
                
                const colors = diamondSystem.geometry.attributes.color.array;
                for(let i=0; i<colors.length; i+=3) {
                    if(colors[i] < 0.9) {
                        colors[i] = c.r;
                        colors[i+1] = c.g;
                        colors[i+2] = c.b;
                    }
                }
                diamondSystem.geometry.attributes.color.needsUpdate = true;
            });

            document.getElementById('img-upload').addEventListener('change', (e)=>{
                const file = e.target.files[0];
                if(!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        
                        // å­˜å‚¨å›¾ç‰‡å®½é«˜æ¯”
                        imageAspectRatio = img.width / img.height;
                        
                        photoSystem.material.map = tex;
                        photoSystem.material.opacity = 0.95;
                        photoSystem.material.needsUpdate = true;

                        if(bigPicturePlane) {
                            bigPicturePlane.material.map = tex;
                            bigPicturePlane.material.needsUpdate = true;
                            
                            // ä½¿ç”¨æ™ºèƒ½å°ºå¯¸è®¡ç®—ï¼Œç¡®ä¿å›¾ç‰‡å®Œæ•´æ˜¾ç¤º
                            const size = calculateFitSize(img.width, img.height, camera.position.z);
                            bigPicturePlane.scale.set(size.width, size.height, 1);
                            
                            // åŒæ­¥æ›´æ–°è¾¹æ¡†å°ºå¯¸
                            if(pictureFrame) {
                                pictureFrame.scale.set(size.width, size.height, 1);
                            }
                        }
                    };
                };
                reader.readAsDataURL(file);
            });

            document.getElementById('fullscreen-btn').addEventListener('click', ()=>{
                if(!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            });
            
            document.getElementById('cam-toggle').addEventListener('click', ()=>{
                document.getElementById('cam-preview').classList.toggle('visible');
            });
            
            document.getElementById('sound-toggle').addEventListener('click', ()=>{
                const btn = document.getElementById('sound-toggle');
                if(!audioContext) {
                    initAudio();
                }
                soundEnabled = !soundEnabled;
                if(soundEnabled) {
                    btn.innerHTML = '<i class="fas fa-volume-up"></i> SOUND';
                    btn.style.color = '#FF69B4';
                    btn.style.borderColor = '#FF69B4';
                    playTone(440, 0.1); // æµ‹è¯•éŸ³æ•ˆ
                } else {
                    btn.innerHTML = '<i class="fas fa-volume-mute"></i> SOUND';
                    btn.style.color = '#aaa';
                    btn.style.borderColor = 'rgba(255,255,255,0.2)';
                }
            });

            // UI åˆ‡æ¢é€»è¾‘
            document.getElementById('ui-toggle-btn').addEventListener('click', (e) => {
                e.stopPropagation(); // é˜²æ­¢å†’æ³¡
                const ui = document.getElementById('ui-layer');
                const icon = document.querySelector('#ui-toggle-btn i');
                
                ui.classList.toggle('ui-hidden');
                
                if (ui.classList.contains('ui-hidden')) {
                    icon.className = 'fas fa-chevron-right';
                } else {
                    icon.className = 'fas fa-chevron-left';
                }
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // å“åº”å¼è°ƒæ•´å›¾ç‰‡å°ºå¯¸
            if(bigPicturePlane && bigPicturePlane.material.map && imageAspectRatio) {
                const tempW = 1000, tempH = 1000 / imageAspectRatio;
                const size = calculateFitSize(tempW, tempH, camera.position.z);
                bigPicturePlane.scale.set(size.width, size.height, 1);
                
                if(pictureFrame) {
                    pictureFrame.scale.set(size.width, size.height, 1);
                }
            }
        }

        // Start
        init();
    </script>
</body>
</html>